using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using UnityEngine;

public class AsyncLoad : MonoBehaviour
{
    private static AsyncLoad instance;
    public static AsyncLoad Instance
    {
        get 
        {
            if(instance == null)
            {
                GameObject gameObject = new GameObject("AsyncLoad");
                gameObject.AddComponent<AsyncLoad>();
                //这个会导致一开始就关闭该对象，所以不设置该属性
                //gameObject.hideFlags = HideFlags.HideAndDontSave;     
                DontDestroyOnLoad(gameObject);
            }
            return instance; 
        }
    }

    /// <summary>    /// 等待栈，用来将所有需要处理的委托存储到该位置，这里是等待区    /// </summary>
    private static List<Action> commands = new List<Action>();
    /// <summary>    /// 处理栈，在子线程中读取该列表数据，然后逐个处理    /// </summary>
    private List<Action> localCommands = new List<Action> ();
    private AutoResetEvent resetEvent;
    private Thread thread;
    private bool isRunning;

    public bool IsRunning
    {
        get { return isRunning; }
    }

    private void Awake()
    {
        if(instance != null)
        {

            Destroy(gameObject);
            return;
        }
        instance = this;
        isRunning = true;
        resetEvent = new AutoResetEvent(false);
        thread = new Thread(Run);
        thread.Start();

    }

    public void Run()
    {

        while (isRunning)
        {
            resetEvent.WaitOne();

            lock (commands)     //线程锁，防止异步导致插入出错
            {
                localCommands.AddRange(commands);
                commands.Clear();
            }
            //处理所有数据
            foreach(var i in localCommands)
            {
                i();
            }
            localCommands.Clear();
        }
    }

    public void AddAction(Action action)
    {
        resetEvent.Set();

        lock (commands)
        {
            commands.Add(action);
        }
    }


    private void OnDisable()
    {
        isRunning = false;
    }
}
