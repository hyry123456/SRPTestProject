// Each #kernel tells which function to compile; you can have many kernels

struct Bounds {
    float3 boundMin;
    float3 boundMax;
};

struct Triangle {
    float3 point0;
    float3 normal0;
    float4 tangen0;
    float2 uv0_0;

    float3 point1;
    float3 normal1;
    float4 tangen1;
    float2 uv0_1;

    float3 point2;
    float3 normal2;
    float4 tangen2;
    float2 uv0_2;
};

StructuredBuffer<Triangle> inputPos;               //输入的全部位置
StructuredBuffer<Bounds> inputBound;               //输入的全部对应的范围
StructuredBuffer<int> inputTris;               //输入的全部对应的
float4 planes[6];                               //判断的6个面
AppendStructuredBuffer<Triangle> cullresult;    //结果位置


int clustLength;      //判断长度

//判断是否在平面内
bool IsOutsideThePlane(float4 plane, float3 pointPosition)
{
    if (dot(plane.xyz, pointPosition) + plane.w > 0)
        return true;
    return false;
}

#pragma kernel ViewCulling


[numthreads(32,1,1)]
void ViewCulling(uint3 groupId : SV_GroupID, uint3 allId: SV_DispatchThreadID)
{
    int index = allId.x;
    if (index >= clustLength) return;

    ////确定这个物体的对应边框
    Bounds bound = inputBound[index];

    bound.boundMin = min(bound.boundMin, bound.boundMax);
    bound.boundMax = max(bound.boundMin, bound.boundMax);

    //为了方便剔除，使用的是固定的范围矩阵

    float4 boundVerts[8];//生成范围对应的顶点，因为是根据顶点判断的
    boundVerts[0] = float4(bound.boundMin, 1);
    boundVerts[1] = float4(bound.boundMax, 1);
    boundVerts[2] = float4(bound.boundMax.x, bound.boundMax.y, bound.boundMin.z, 1);    //右后上
    boundVerts[3] = float4(bound.boundMax.x, bound.boundMin.y, bound.boundMax.z, 1);    //右前下
    boundVerts[6] = float4(bound.boundMax.x, bound.boundMin.y, bound.boundMin.z, 1);    //右后下
    boundVerts[4] = float4(bound.boundMin.x, bound.boundMax.y, bound.boundMax.z, 1);    //左前上
    boundVerts[5] = float4(bound.boundMin.x, bound.boundMax.y, bound.boundMin.z, 1);    //左后上
    boundVerts[7] = float4(bound.boundMin.x, bound.boundMin.y, bound.boundMax.z, 1);    //左前下
    int i, j;
    //如果8个顶点都在某个面外，则肯定在视锥体外面
    for ( i = 0; i < 6; i++)
    {
        for ( j = 0; j < 8; j++)
        {
            float3 boundPosition = boundVerts[j].xyz;

            if (!IsOutsideThePlane(planes[i], boundPosition))
                break;
            if (j == 7)
                return;
        }
    }

    int beginIndex = index * 32;
    for (i = 0; i < 32; i++) {
        Triangle triangles = inputPos[beginIndex + i];
        cullresult.Append(triangles);
    }
}


#pragma kernel ProjectMatrixCulling

float4x4 _ProjectMatrix;
//判断点是否在投影矩阵外
bool IsOutsideTheProjectBox(float4 pointPosition)
{
    float4 projectPos = mul(_ProjectMatrix, pointPosition);
    if (projectPos.x >= projectPos.w || projectPos.x <= -projectPos.w) return true;
    if (projectPos.y >= projectPos.w || projectPos.y <= -projectPos.w) return true;
    if (projectPos.z >= projectPos.w || projectPos.z <= -projectPos.w) return true;

    return false;
}


[numthreads(32, 1, 1)]
void ProjectMatrixCulling(uint3 groupId : SV_GroupID, uint3 allId : SV_DispatchThreadID)
{
    int index = allId.x;
    if (index >= clustLength) return;

    //确定这个物体的对应边框
    Bounds bound = inputBound[index];

    bound.boundMin = min(bound.boundMin, bound.boundMax);
    bound.boundMax = max(bound.boundMin, bound.boundMax);

    //为了方便剔除，使用的是固定的范围矩阵

    float4 boundVerts[8];//生成范围对应的顶点，因为是根据顶点判断的
    boundVerts[0] = float4(bound.boundMin, 1);
    boundVerts[1] = float4(bound.boundMax, 1);
    boundVerts[2] = float4(bound.boundMax.x, bound.boundMax.y, bound.boundMin.z, 1);    //右后上
    boundVerts[3] = float4(bound.boundMax.x, bound.boundMin.y, bound.boundMax.z, 1);    //右前下
    boundVerts[6] = float4(bound.boundMax.x, bound.boundMin.y, bound.boundMin.z, 1);    //右后下
    boundVerts[4] = float4(bound.boundMin.x, bound.boundMax.y, bound.boundMax.z, 1);    //左前上
    boundVerts[5] = float4(bound.boundMin.x, bound.boundMax.y, bound.boundMin.z, 1);    //左后上
    boundVerts[7] = float4(bound.boundMin.x, bound.boundMin.y, bound.boundMax.z, 1);    //左前下

    int i, j;
    for ( j = 0; j < 8; j++)
    {
        float4 boundPosition = boundVerts[j];

        if (!IsOutsideTheProjectBox(boundPosition))
            break;
        if (j == 7)
            return;
    }

    int beginIndex = index * 32;
    for (i = 0; i < 32; i++) {
        Triangle triangles = inputPos[beginIndex + i];
        cullresult.Append(triangles);
    }
}


//-------------------Lighting Cull---------------
struct LightingTriangle {
    float3 point0;
    float3 normal0;
    float4 tangen0;
    float2 uv0_0;

    float3 point1;
    float3 normal1;
    float4 tangen1;
    float2 uv0_1;

    float3 point2;
    float3 normal2;
    float4 tangen2;
    float2 uv0_2;

    int lightArray0;
    int lightArray1;
};

#define MAX_OTHER_LIGHT_COUNT 64

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"

CBUFFER_START(_CustomLight)
    int _OtherLightCount;
    float4 _OtherLightPositions[MAX_OTHER_LIGHT_COUNT];
    float4 _OtherLightDirectionsAndMasks[MAX_OTHER_LIGHT_COUNT];
    float4 _OtherLightSpotAngles[MAX_OTHER_LIGHT_COUNT];
    float4 _OtherLightShadowData[MAX_OTHER_LIGHT_COUNT];
CBUFFER_END

AppendStructuredBuffer<LightingTriangle> _LightCullResult;    //结果位置

#pragma kernel ViewCullingWithLighting

LightingTriangle CopyTriangleToLightingTriangle(Triangle tri, int lightArray0, int lightArray1) {
    LightingTriangle lightTri;

    lightTri.point0 = tri.point0;
    lightTri.normal0 = tri.normal0;
    lightTri.tangen0 = tri.tangen0;
    lightTri.uv0_0 = tri.uv0_0;

    lightTri.point1 = tri.point1;
    lightTri.normal1 = tri.normal1;
    lightTri.tangen1 = tri.tangen1;
    lightTri.uv0_1 = tri.uv0_1;

    lightTri.point2 = tri.point2;
    lightTri.normal2 = tri.normal2;
    lightTri.tangen2 = tri.tangen2;
    lightTri.uv0_2 = tri.uv0_2;

    lightTri.lightArray0 = lightArray0;
    lightTri.lightArray1 = lightArray1;

    return lightTri;
}

int CheckPointIsInLightingRange(float3 worldPos, int lightIndex) {
    float3 lightPos = _OtherLightPositions[lightIndex].xyz;
    float3 ray = lightPos - worldPos;
    float distanceSqr = dot(ray, ray);
    if (distanceSqr < (1 / _OtherLightPositions[lightIndex].w)) {
        return 8;   //表示在范围中
    }

    //用来确认方向
    int re = 0;
    re += (ray.y > 0) ? 4 : 0;
    re += (ray.x > 0) ? 2 : 0;
    re += (ray.z > 0) ? 1 : 0;
    return re;
}

int GetLightArray0(float4 boundVerts[8]) {
    int lightArray0 = 0;
    for (int i = 0; i < 32 && i < _OtherLightCount; i++) {

        float3 boundPosition = boundVerts[0].xyz;
        int lightDir = CheckPointIsInLightingRange(boundPosition, i);   //一开始赋予初始方向值
        if (lightDir > 7) {
            lightArray0 = (1 << i) | lightArray0;
            continue;
        }
        //确定了方向，就没有必要全部检测了，检测对角即可
        for (int j = 1; j < 4; j++) {
            boundPosition = boundVerts[j].xyz;
            int nowDir = CheckPointIsInLightingRange(boundPosition, i);
            if (nowDir != lightDir || nowDir > 7) {
                lightArray0 = (1 << i) | lightArray0;
                break;
            }
        }
    }
    return lightArray0;
}

int GetLightArray1(float4 boundVerts[8]) {
    int lightArray1 = 0;
    for (int i = 32; i < 64 && i < _OtherLightCount; i++) {

        float3 boundPosition = boundVerts[0].xyz;
        int lightDir = CheckPointIsInLightingRange(boundPosition, i);   //一开始赋予初始方向值
        if (lightDir > 7) {
            lightArray1 = (1 << (i - 32)) | lightArray1;
            continue;
        }

        for (int j = 1; j < 4; j++) {
            float3 boundPosition = boundVerts[j].xyz;
            int nowDir = CheckPointIsInLightingRange(boundPosition, i);

            if (nowDir != lightDir || nowDir > 7) {
                lightArray1 = (1 << ( i - 32) ) | lightArray1;
                break;
            }
        }
    }
    return lightArray1;
}


[numthreads(32, 1, 1)]
void ViewCullingWithLighting(uint3 groupId : SV_GroupID, uint3 allId : SV_DispatchThreadID)
{
    int index = allId.x;
    if (index >= clustLength) return;
    ////确定这个物体的对应边框
    Bounds bound = inputBound[index];

    bound.boundMin = min(bound.boundMin, bound.boundMax);
    bound.boundMax = max(bound.boundMin, bound.boundMax);

    //为了方便剔除，使用的是固定的范围矩阵

    float4 boundVerts[8];//生成范围对应的顶点，因为是根据顶点判断的
    boundVerts[0] = float4(bound.boundMin, 1);                                          //左后下
    boundVerts[1] = float4(bound.boundMax, 1);                                          //右前上
    boundVerts[2] = float4(bound.boundMin.x, bound.boundMin.y, bound.boundMax.z, 1);    //左前下
    boundVerts[3] = float4(bound.boundMin.x, bound.boundMax.y, bound.boundMin.z, 1);    //左后上
    boundVerts[4] = float4(bound.boundMin.x, bound.boundMax.y, bound.boundMax.z, 1);    //左前上
    boundVerts[5] = float4(bound.boundMax.x, bound.boundMin.y, bound.boundMax.z, 1);    //右前下
    boundVerts[6] = float4(bound.boundMax.x, bound.boundMin.y, bound.boundMin.z, 1);    //右后下
    boundVerts[7] = float4(bound.boundMax.x, bound.boundMax.y, bound.boundMin.z, 1);    //右后上
    int i, j;
    //如果8个顶点都在某个面外，则肯定在视锥体外面
    for ( i = 0; i < 6; i++)
    {
        for ( j = 0; j < 8; j++)
        {
            float3 boundPosition = boundVerts[j].xyz;

            if (!IsOutsideThePlane(planes[i], boundPosition))
                break;
            if (j == 7)
                return;
        }
    }

    int lightArray0 = GetLightArray0(boundVerts);
    int lightArray1 = GetLightArray1(boundVerts);

    int beginIndex = index * 32;
    for ( i = 0; i < 32; i++) {
        Triangle triangles = inputPos[beginIndex + i];
        LightingTriangle lightTri = CopyTriangleToLightingTriangle(triangles, lightArray0, lightArray1);
        _LightCullResult.Append(lightTri);
    }
}
