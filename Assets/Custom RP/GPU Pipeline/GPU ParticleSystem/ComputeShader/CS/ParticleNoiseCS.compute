#include "../HLSL/ParticleInclude.hlsl"

struct NoiseParticleData {
    float4 random;          //xyz是随机数，w是目前存活时间
    int2 index;             //状态标记，x是当前编号，y是是否存活
    float3 worldPos;        //当前位置
    float4 uvTransData;     //uv动画需要的数据
    float interpolation;    //插值需要的数据
    float4 color;           //颜色值，包含透明度
    float size;             //粒子大小
    float3 nowSpeed;        //xyz是当前速度，w是存活时间
    float liveTime;         //最多存活时间
};



#pragma kernel NoiseParticle
#define _PI 3.1415926


RWStructuredBuffer<NoiseParticleData> _ParticleNoiseBuffer;         //输入的buffer

float _Arc;         //设置的角度，圆形初始化位置时用到该数据
float _Radius;
int _Octave;        //循环的次数，控制生成噪声的细节
float _Frequency;   //采样变化的频率，也就是对坐标的缩放大小
float _Intensity;   //影响的强度值


//使用参数方程作为坐标生成的根据
float3 GetSphereBeginPos(float2 random) {
    float u = lerp(0, _Arc, random.x);
    float v = lerp(0, _Arc, random.y);
    float3 pos;
    pos.x = _Radius * cos(u);
    pos.y = _Radius * sin(u) * cos(v);
    pos.z = _Radius * sin(u) * sin(v);
    return pos;
}

NoiseParticleData InitialParticle(NoiseParticleData i) {
    i.worldPos = GetSphereBeginPos(i.random.xy);
    i.random.w = 0;
    i.nowSpeed = 0;
    return i;
}

//生成随机方向
float3 hash3d(float3 input) {
    const float3 k = float3(0.3183099, 0.3678794, 0.38975765);
    input = input * k + k.zyx;
    return -1.0 + 2.0 * frac(16.0 * k * frac(input.x * input.y * input.z * (input.x + input.y + input.z)));
}

//进行插值
float Cos_Interpolate(float a, float b, float t)
{
    float ft = t * 3.14159;
    t = (1 - cos(ft)) * 0.5;
    return a * (1 - t) + t * b;
}

//根据3维坐标生成一个float值
float Perlin3DFun(float3 pos) {
    float3 i = floor(pos);
    float3 f = frac(pos);

    //获得八个点，也就是立方体的八个点的对应向量
    float3 g0 = hash3d(i + float3(0.0, 0.0, 0.0));
    float3 g1 = hash3d(i + float3(1.0, 0.0, 0.0));
    float3 g2 = hash3d(i + float3(0.0, 1.0, 0.0));
    float3 g3 = hash3d(i + float3(0.0, 0.0, 1.0));
    float3 g4 = hash3d(i + float3(1.0, 1.0, 0.0));
    float3 g5 = hash3d(i + float3(0.0, 1.0, 1.0));
    float3 g6 = hash3d(i + float3(1.0, 0.0, 1.0));
    float3 g7 = hash3d(i + float3(1.0, 1.0, 1.0));

    //获得点乘后的大小
    float v0 = dot(g0, f - float3(0.0, 0.0, 0.0));  //左前下
    float v1 = dot(g1, f - float3(1.0, 0.0, 0.0));  //右前下
    float v2 = dot(g2, f - float3(0.0, 1.0, 0.0));  //左前上
    float v3 = dot(g3, f - float3(0.0, 0.0, 1.0));  //左后下
    float v4 = dot(g4, f - float3(1.0, 1.0, 0.0));  //右前上
    float v5 = dot(g5, f - float3(0.0, 1.0, 1.0));  //左后上
    float v6 = dot(g6, f - float3(1.0, 0.0, 1.0));  //右后下
    float v7 = dot(g7, f - float3(1.0, 1.0, 1.0));  //右后上

    float inter0 = Cos_Interpolate(v0, v2, f.y);
    float inter1 = Cos_Interpolate(v1, v4, f.y);
    float inter2 = Cos_Interpolate(inter0, inter1, f.x);    //前4点

    float inter3 = Cos_Interpolate(v3, v5, f.y);
    float inter4 = Cos_Interpolate(v6, v7, f.y);
    float inter5 = Cos_Interpolate(inter3, inter4, f.x);

    float inter6 = Cos_Interpolate(inter2, inter5, f.z);

    return inter6;
}

//采样噪声，通过参数确定是否多次采样
float Perlin3DFBM(float3 pos, int octave) {
    float noise = 0.0;
    float frequency = 1.0;
    float amplitude = 1.0;

    for (int i = 0; i < octave; i++)
    {
        noise += Perlin3DFun(pos * frequency) * amplitude;
        frequency *= 2.0;
        amplitude *= 0.5;
    }
    return noise;
}

//根据坐标生成一个方向
float3 CurlNoise3D(float3 pos, int octave)
{
    float eps = 0.1;
    float x = pos.x;
    float y = pos.y;
    float z = pos.z;
    float n1 = Perlin3DFBM(float3(x, y + eps, z), octave);
    float n2 = Perlin3DFBM(float3(x, y - eps, z), octave).x;
    float a = (n1 - n2) / (2.0 * eps);

    float n3 = Perlin3DFBM(float3(x + eps, y, z), octave).x;
    float n4 = Perlin3DFBM(float3(x - eps, y, z), octave).x;
    float b = (n3 - n4) / (2.0 * eps);

    float n5 = Perlin3DFBM(float3(x, y, z + eps), octave).x;
    float n6 = Perlin3DFBM(float3(x, y, z - eps), octave).x;
    float c = (n5 - n6) / (2.0 * eps);

    //Result[id.xy] = float4(a, b, 0, 1);
    return float3(a, b, c);
}



[numthreads(64, 1, 1)]
void NoiseParticle(int3 gid : SV_GroupID, int index : SV_GroupIndex)
{
	int allIndex = gid.x * 64 + index;
	if (allIndex >= _ParticleCount) return;

    NoiseParticleData o = _ParticleNoiseBuffer[allIndex];

    if (o.index.x > _ArriveIndex) {
        o.index.y = -1;
        _ParticleNoiseBuffer[allIndex] = o;    //表示不显示
        return;
    }
    if (o.index.x == _ArriveIndex) {    //初始化
        o = InitialParticle(o);
    }
    if (o.random.w > o.liveTime) {       //超过存活周期，需要初始化
        o = InitialParticle(o);
        o.index.x += _ParticleCount;
        o.index.x %= 1000000007;
        o.index.y = -1;                 //表示不显示
        _ParticleNoiseBuffer[allIndex] = o;
        return;
    }
    else
        o.index.y = 1;

    o.nowSpeed += CurlNoise3D(o.worldPos * _Frequency, _Octave) * _Intensity;
    //o.nowSpeed = CurlNoise3D(o.worldPos * _Frequency, _Octave);
    o.worldPos += o.nowSpeed * _Time.y;
    o.random.w += _Time.y;

    float time_01 = o.random.w / o.liveTime;
    AnimateUVData uvData = AnimateUV(time_01);
    o.uvTransData = uvData.uvData;
    o.interpolation = uvData.interpolation;
    o.color = float4(LoadColor(time_01), LoadAlpha(time_01));
    o.size = LoadSize(time_01);

    _ParticleNoiseBuffer[allIndex] = o;
}
