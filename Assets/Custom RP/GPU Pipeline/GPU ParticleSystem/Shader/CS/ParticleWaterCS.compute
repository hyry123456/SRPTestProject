

#pragma kernel Water_PerFrame
#pragma kernel Water_PerFixFrame


struct WaterGroupData {
    float4 plane;       //判断用的平面，xyz=normal，w=D
    float2 lifeTime;     //存活时间，x=beginTime，y=endTime
    float3 beginDir;    //初始方向
    float3 beginPos;    //初始位置
};

struct WaterParticleData {
    float4 random;          //xyzw都是随机数，w用来确定死亡时间
    int index;             //状态标记，确定是否存活
    float3 worldPos;        //当前位置
    float alpha;           //颜色值，包含透明度
    float size;             //粒子大小
    float3 nowSpeed;        //xyz是当前速度
};

float4 _Alphas[6];  //透明度计算用的数据
float4 _Sizes[6];  //大小

RWStructuredBuffer<WaterGroupData> _WaterGroupBuffer;         //根据的buffer数据
RWStructuredBuffer<WaterParticleData> _WaterParticleBuffer;         //单个粒子的buffer数据
float4 _Time;       //x=场景时间、y=deletaTime, z=fixDeletaTime
float3 _NoiseData;  //x=octave, y=frequency, z=intensity
int _ParticleCount;


float LoadAlpha(float time_01) {
    // return time_01;
    for (int i = 1; i < 6; i++) {
        if (time_01 <= _Alphas[i].y) {
            float radio = smoothstep(_Alphas[i - 1].y, _Alphas[i].y, time_01);
            return lerp(_Alphas[i - 1].x, _Alphas[i].x, radio);
        }
    }
    return 1;
}

//时间控制函数，用来读取Curve中的值
float LoadSize(float time_01) {
    //有数据才循环
    for (int i = 1; i < 6; i++) {
        //找到在范围中的
        if (time_01 <= _Sizes[i].x) {
            //Unity的Curve的曲线本质上是一个三次多项式插值，公式为：y = ax^3 + bx^2 + cx +d
            float a = (_Sizes[i - 1].w + _Sizes[i].z) * (_Sizes[i].x - _Sizes[i - 1].x)
                - 2 * (_Sizes[i].y - _Sizes[i - 1].y);
            float b = (-2 * _Sizes[i - 1].w - _Sizes[i].z) *
                (_Sizes[i].x - _Sizes[i - 1].x) + 3 * (_Sizes[i].y - _Sizes[i - 1].y);
            float c = _Sizes[i - 1].w * (_Sizes[i].x - _Sizes[i - 1].x);
            float d = _Sizes[i - 1].y;

            float trueTime = (time_01 - _Sizes[i - 1].x) / (_Sizes[i].x - _Sizes[i - 1].x);
            return a * pow(trueTime, 3) + b * pow(trueTime, 2) + c * trueTime + d;

        }
    }
    return 0;
}

//判断是否在平面内
bool IsOutsideThePlane(float4 plane, float3 pointPosition)
{
    if (dot(plane.xyz, pointPosition) + plane.w > 0)
        return true;
    return false;
}

//生成随机方向
float3 hash3d(float3 input) {
    const float3 k = float3(0.3183099, 0.3678794, 0.38975765);
    input = input * k + k.zyx;
    return -1.0 + 2.0 * frac(16.0 * k * frac(input.x * input.y * input.z * (input.x + input.y + input.z)));
}

//进行插值
float Cos_Interpolate(float a, float b, float t)
{
    float ft = t * 3.14159;
    t = (1 - cos(ft)) * 0.5;
    return a * (1 - t) + t * b;
}

//根据3维坐标生成一个float值
float Perlin3DFun(float3 pos) {
    float3 i = floor(pos);
    float3 f = frac(pos);

    //获得八个点，也就是立方体的八个点的对应向量
    float3 g0 = hash3d(i + float3(0.0, 0.0, 0.0));
    float3 g1 = hash3d(i + float3(1.0, 0.0, 0.0));
    float3 g2 = hash3d(i + float3(0.0, 1.0, 0.0));
    float3 g3 = hash3d(i + float3(0.0, 0.0, 1.0));
    float3 g4 = hash3d(i + float3(1.0, 1.0, 0.0));
    float3 g5 = hash3d(i + float3(0.0, 1.0, 1.0));
    float3 g6 = hash3d(i + float3(1.0, 0.0, 1.0));
    float3 g7 = hash3d(i + float3(1.0, 1.0, 1.0));

    //获得点乘后的大小
    float v0 = dot(g0, f - float3(0.0, 0.0, 0.0));  //左前下
    float v1 = dot(g1, f - float3(1.0, 0.0, 0.0));  //右前下
    float v2 = dot(g2, f - float3(0.0, 1.0, 0.0));  //左前上
    float v3 = dot(g3, f - float3(0.0, 0.0, 1.0));  //左后下
    float v4 = dot(g4, f - float3(1.0, 1.0, 0.0));  //右前上
    float v5 = dot(g5, f - float3(0.0, 1.0, 1.0));  //左后上
    float v6 = dot(g6, f - float3(1.0, 0.0, 1.0));  //右后下
    float v7 = dot(g7, f - float3(1.0, 1.0, 1.0));  //右后上

    float inter0 = Cos_Interpolate(v0, v2, f.y);
    float inter1 = Cos_Interpolate(v1, v4, f.y);
    float inter2 = Cos_Interpolate(inter0, inter1, f.x);    //前4点

    float inter3 = Cos_Interpolate(v3, v5, f.y);
    float inter4 = Cos_Interpolate(v6, v7, f.y);
    float inter5 = Cos_Interpolate(inter3, inter4, f.x);

    float inter6 = Cos_Interpolate(inter2, inter5, f.z);

    return inter6;
}

//采样噪声，通过参数确定是否多次采样
float Perlin3DFBM(float3 pos, int octave) {
    float noise = 0.0;
    float frequency = 1.0;
    float amplitude = 1.0;

    for (int i = 0; i < octave; i++)
    {
        noise += Perlin3DFun(pos * frequency) * amplitude;
        frequency *= 2.0;
        amplitude *= 0.5;
    }
    return noise;
}

//根据坐标生成一个方向
float3 CurlNoise3D(float3 pos, int octave)
{
    float eps = 0.1;
    float x = pos.x;
    float y = pos.y;
    float z = pos.z;
    float n1 = Perlin3DFBM(float3(x, y + eps, z), octave);
    float n2 = Perlin3DFBM(float3(x, y - eps, z), octave).x;
    float a = (n1 - n2) / (2.0 * eps);

    float n3 = Perlin3DFBM(float3(x + eps, y, z), octave).x;
    float n4 = Perlin3DFBM(float3(x - eps, y, z), octave).x;
    float b = (n3 - n4) / (2.0 * eps);

    float n5 = Perlin3DFBM(float3(x, y, z + eps), octave).x;
    float n6 = Perlin3DFBM(float3(x, y, z - eps), octave).x;
    float c = (n5 - n6) / (2.0 * eps);

    return float3(a, b, c);
}



//逐帧刷新的方法，用来控制与渲染直接相关的数据
[numthreads(64, 1, 1)]
void Water_PerFrame(int3 gid : SV_GroupID, int index : SV_GroupIndex)
{
    int objIndex = gid.x * 64 + index;
	if (objIndex >= _ParticleCount) return;

    int groupIndex = gid.x;

    WaterGroupData group = _WaterGroupBuffer[groupIndex];
    WaterParticleData particle = _WaterParticleBuffer[objIndex];

    if (group.lifeTime.y < _Time.x) {
        particle.index = -1;
        _WaterParticleBuffer[objIndex] = particle;    //表示不显示
        return;
    }
    //开始运行，需要初始化
    if (particle.index == -1) {
        particle.worldPos = group.beginPos;
        particle.nowSpeed = lerp(group.beginDir/2.0, group.beginDir, particle.random.xyz);
    }
    particle.index = 1;                           //启动粒子

    particle.worldPos += particle.nowSpeed * _Time.y;      //进行位移

    float lifeTime = (group.lifeTime.y - group.lifeTime.x) * particle.random.w;
    float time_01 = saturate((_Time.x - group.lifeTime.x) / lifeTime);

    particle.alpha = LoadAlpha(time_01);
    particle.size =  LoadSize(time_01);

    _WaterParticleBuffer[objIndex] = particle;
}


[numthreads(64, 1, 1)]
void Water_PerFixFrame(int3 gid : SV_GroupID, int index : SV_GroupIndex){
    int objIndex = gid.x * 64 + index;
	if (objIndex >= _ParticleCount) return;

    int groupIndex = gid.x;

    WaterGroupData group = _WaterGroupBuffer[groupIndex];
    WaterParticleData particle = _WaterParticleBuffer[objIndex];
    if (particle.index == -1) {
        return;
    }

    //重力
    particle.nowSpeed.y -= 9.8 * _Time.z;
    //噪声影响速度
    particle.nowSpeed += CurlNoise3D(particle.worldPos * _NoiseData.y, (int)_NoiseData.x) * _NoiseData.z * _Time.z;

    //判断是否越过平面，越过就往外推
    if(!IsOutsideThePlane(group.plane, particle.worldPos) && dot(group.plane.xyz, normalize(particle.nowSpeed)) < 0){
        particle.nowSpeed += length(particle.nowSpeed) * group.plane.xyz * 0.3;   //给一个向外的力
    }


    _WaterParticleBuffer[objIndex] = particle;
}