#pragma kernel ValueNoise

RWTexture2D<float4> Result;
int textureSize;    //图片的大小，因为是正方形，所以只用输入长度即可

float hash2d(float2 input) {
    return frac(1.0e4 * sin(17.0 * input.x + 0.1 * input.y) *
        (0.1 + abs(sin(12.0 * input.y + input.x))));
}

[numthreads(8,8,1)]
void ValueNoise(uint3 id : SV_DispatchThreadID, uint3 group : SV_GroupID)
{
    float2 groupUV = float2(group.x, group.y) ;

    float2 uv = (id.xy - group.xy * 8) / 8.0;

    float2 intPos = floor(groupUV);

    float2 fracPos = frac(uv);

    //三线性插值需要的参数
    float2 u = fracPos * fracPos * (3.0 - 2.0 * fracPos);

    //获得4个边界的值，也就是小方格的是个角的值，这4个角的值是固定的
    float va = hash2d(intPos + float2(0.0, 0.0));
    float vb = hash2d(intPos + float2(1.0, 0.0));
    float vc = hash2d(intPos + float2(0.0, 1.0));
    float vd = hash2d(intPos + float2(1.0, 1.0));

    float k0 = va;
    float k1 = vb - va;//horizontal
    float k2 = vc - va;//vertical
    float k4 = va - vb - vc + vd;

    //插值获得结果
    float value = k0 + k1 * u.x + k2 * u.y + k4 * u.x * u.y;

    //直接赋值
    Result[id.xy] = value;
}


#pragma kernel Perlin2DNoise

float2 hash2d2(float2 x) {
    const float2 k = float2(0.3183099, 0.3678794);
    x = x * k + k.yx;
    return -1.0 + 2.0 * frac(16.0 * k * frac(x.x * x.y * (x.x + x.y)));
}

[numthreads(8, 8, 1)]
void Perlin2DNoise(uint3 id : SV_DispatchThreadID, uint3 group : SV_GroupID) {

    float2 groupUV = float2(group.x, group.y);
    float2 uv = (id.xy - group.xy * 8) / 8.0;

    float2 intPos = floor(groupUV);

    float2 f = frac(uv);

    float2 u = f * f * (3.0 - 2.0 * f);
    float2 du = 6.0 * f * (1.0 - f);

    float2 ga = hash2d2(intPos + float2(0.0, 0.0));
    float2 gb = hash2d2(intPos + float2(1.0, 0.0));
    float2 gc = hash2d2(intPos + float2(0.0, 1.0));
    float2 gd = hash2d2(intPos + float2(1.0, 1.0));

    float va = dot(ga, f - float2(0.0, 0.0));
    float vb = dot(gb, f - float2(1.0, 0.0));
    float vc = dot(gc, f - float2(0.0, 1.0));
    float vd = dot(gd, f - float2(1.0, 1.0));

    float value = va + u.x * (vb - va) + u.y * (vc - va) + u.x * u.y * (va - vb - vc + vd);
    value = 0.5 + 0.5 * value;
    Result[id.xy] = value;
}


#pragma kernel Worley2D

[numthreads(32, 32, 1)]
void Worley2D(uint3 id : SV_DispatchThreadID, uint3 group : SV_GroupID)
{
    float Dist = 16.0;
    float2 groupUV = float2(group.x, group.y);
    float2 uv = (id.xy - group.xy * 32) / 32.0;
    //search range
    const int Range = 5;
    for (int X = -Range; X <= Range; X++)
    {
        for (int Y = -Range; Y <= Range; Y++)
        {
            float D = distance(hash2d2(groupUV + float2(X, Y)) + float2(X, Y), uv);
            Dist = min(Dist, D);
        }
    }

    //Result[id.xy] = Dist;
    Result[id.xy] = 1.0 - 2.0 * Dist;
}

#pragma kernel Worley2DFBM

int octave;

float Worley2DFun(uint3 id, uint3 group) {
    float Dist = 16.0;
    float2 groupUV = float2(group.x, group.y);
    float2 uv = (id.xy - group.xy * 32) / 32.0;
    //search range
    const int Range = 5;
    for (int X = -Range; X <= Range; X++)
    {
        for (int Y = -Range; Y <= Range; Y++)
        {
            float D = distance(hash2d2(groupUV + float2(X, Y)) + float2(X, Y), uv);
            Dist = min(Dist, D);
        }
    }

    return Dist;
}

[numthreads(32, 32, 1)]
void Worley2DFBM(uint3 id : SV_DispatchThreadID, uint3 group : SV_GroupID) {
    float noise = 0.0;
    float frequency = 1.0;
    float amplitude = 1.0;

    //float2 groupUV = float2(group.x, group.y);
    //float2 uv = (id.xy - group.xy * 8) / 8.0;

    for (int i = 0; i < octave; i++)
    {
        noise += Worley2DFun(id, group) * amplitude;
        frequency *= 2.0;
        amplitude *= 0.5;
    }

    Result[id.xy] = noise;
}

#pragma kernel Perlin2DFBM

float3 Perlin2DFun(float2 uv) {
    float2 i = floor(uv);
    float2 f = frac(uv);

    float2 u = f * f * (3.0 - 2.0 * f);
    float2 du = 6.0 * f * (1.0 - f);

    float2 ga = hash2d2(i + float2(0.0, 0.0));
    float2 gb = hash2d2(i + float2(1.0, 0.0));
    float2 gc = hash2d2(i + float2(0.0, 1.0));
    float2 gd = hash2d2(i + float2(1.0, 1.0));

    float va = dot(ga, f - float2(0.0, 0.0));
    float vb = dot(gb, f - float2(1.0, 0.0));
    float vc = dot(gc, f - float2(0.0, 1.0));
    float vd = dot(gd, f - float2(1.0, 1.0));

    return float3(va + u.x * (vb - va) + u.y * (vc - va) + u.x * u.y * (va - vb - vc + vd),   // value
        ga + u.x * (gb - ga) + u.y * (gc - ga) + u.x * u.y * (ga - gb - gc + gd) +  // derivatives，用来生成zw值
        du * (u.yx * (va - vb - vc + vd) + float2(vb, vc) - va));
}

[numthreads(32, 32, 1)]
void Perlin2DFBM(uint3 id : SV_DispatchThreadID, uint3 group : SV_GroupID) {
    float3 noise = 0.0;
    float frequency = 1.0;
    float amplitude = 1.0;

    float2 uv = id.xy / 32.0;

    //循环n次，octave是一个输入值
    for (int i = 0; i < octave; i++)
    {
        noise += Perlin2DFun(uv * frequency) * amplitude;
        frequency *= 2.0;
        amplitude *= 0.5;
    }

    //缩放到01，因为柏林噪声结果为-1至1，表示一个方向值
    noise = 0.5 * noise + 0.5;

    Result[id.xy] = float4(noise, 1);
}

#pragma kernel CurlNoise

[numthreads(32, 32, 1)]
void CurlNoise(uint3 id : SV_DispatchThreadID, uint3 group : SV_GroupID)
{
    float2 uv = id.xy / 32.0;

    float eps = 0.00001;
    float x = uv.x;
    float y = uv.y;
    int firstOctave = 3;
    int accumOctaves = 3;
    bool revertPerlin = false;
    float n1 = Perlin2DFun(float2(x, y + eps)).x;
    float n2 = Perlin2DFun(float2(x, y - eps)).x;
    float a = (n1 - n2) / (2.0 * eps);

    float n3 = Perlin2DFun(float2(x + eps, y)).x;
    float n4 = Perlin2DFun(float2(x - eps, y)).x;
    float b = (n3 - n4) / (2.0 * eps);

    Result[id.xy] = float4(a, -b, 0, 1);
}


#pragma kernel CurlNoise3D

float texSize;

float3 hash3d(float3 input) {
    const float3 k = float3(0.3183099, 0.3678794, 0.38975765);
    input = input * k + k.zyx;
    return -1.0 + 2.0 * frac(16.0 * k * frac(input.x * input.y * input.z * (input.x + input.y + input.z)));
}

float Cos_Interpolate(float a, float b, float t)
{
    float ft = t * 3.14159;
    t = (1 - cos(ft)) * 0.5;
    return a * (1 - t) + t * b;
}

float Perlin3DFun(float3 pos) {
    float3 i = floor(pos);
    float3 f = frac(pos);

    //获得八个点，也就是立方体的八个点的对应向量
    float3 g0 = hash3d(i + float3(0.0, 0.0, 0.0));
    float3 g1 = hash3d(i + float3(1.0, 0.0, 0.0));
    float3 g2 = hash3d(i + float3(0.0, 1.0, 0.0));
    float3 g3 = hash3d(i + float3(0.0, 0.0, 1.0));
    float3 g4 = hash3d(i + float3(1.0, 1.0, 0.0));
    float3 g5 = hash3d(i + float3(0.0, 1.0, 1.0));
    float3 g6 = hash3d(i + float3(1.0, 0.0, 1.0));
    float3 g7 = hash3d(i + float3(1.0, 1.0, 1.0));

    //获得点乘后的大小
    float v0 = dot(g0, f - float3(0.0, 0.0, 0.0));  //左前下
    float v1 = dot(g1, f - float3(1.0, 0.0, 0.0));  //右前下
    float v2 = dot(g2, f - float3(0.0, 1.0, 0.0));  //左前上
    float v3 = dot(g3, f - float3(0.0, 0.0, 1.0));  //左后下
    float v4 = dot(g4, f - float3(1.0, 1.0, 0.0));  //右前上
    float v5 = dot(g5, f - float3(0.0, 1.0, 1.0));  //左后上
    float v6 = dot(g6, f - float3(1.0, 0.0, 1.0));  //右后下
    float v7 = dot(g7, f - float3(1.0, 1.0, 1.0));  //右后上

    float inter0 = Cos_Interpolate(v0, v2, f.y);
    float inter1 = Cos_Interpolate(v1, v4, f.y);
    float inter2 = Cos_Interpolate(inter0, inter1, f.x);    //前4点

    float inter3 = Cos_Interpolate(v3, v5, f.y);
    float inter4 = Cos_Interpolate(v6, v7, f.y);
    float inter5 = Cos_Interpolate(inter3, inter4, f.x);

    float inter6 = Cos_Interpolate(inter2, inter5, f.z);

    return inter6;
}

float Perlin3DFBM(float3 pos, int octave) {
    float noise = 0.0;
    float frequency = 1.0;
    float amplitude = 1.0;

    //循环n次，octave是一个输入值
    for (int i = 0; i < octave; i++)
    {
        noise += Perlin3DFun(pos * frequency) * amplitude;
        frequency *= 2.0;
        amplitude *= 0.5;
    }
    //缩放到01，因为柏林噪声结果为-1至1，表示一个方向值
    return 0.5 * noise + 0.5;
}

[numthreads(32, 32, 1)]
void CurlNoise3D(uint3 id : SV_DispatchThreadID, uint3 group : SV_GroupID)
{
    float2 uv = id.xy / texSize;

    float eps = 0.1;
    float x = uv.x;
    float y = uv.y;
    float n1 = Perlin3DFBM(float3(x, y + eps, 1), octave);
    float n2 = Perlin3DFBM(float3(x, y - eps, 1), octave).x;
    float a = (n1 - n2) / (2.0 * eps);

    float n3 = Perlin3DFBM(float3(x + eps, y, 1), octave).x;
    float n4 = Perlin3DFBM(float3(x - eps, y, 1), octave).x;
    float b = (n3 - n4) / (2.0 * eps);

    Result[id.xy] = float4(a, b, 0, 1);
}
